"""
Pydantic models for blockchain signals and insights.

These models define the data structures used throughout the signal-to-insight pipeline,
ensuring type safety and validation across services.
"""

from datetime import datetime
from typing import Any, Dict, List, Optional
from pydantic import BaseModel, Field, field_validator, ConfigDict
from enum import Enum


class SignalType(str, Enum):
    """Enumeration of supported signal types."""
    MEMPOOL = "mempool"
    EXCHANGE = "exchange"
    MINER = "miner"
    WHALE = "whale"
    TREASURY = "treasury"
    PREDICTIVE = "predictive"


class EntityType(str, Enum):
    """Enumeration of entity types."""
    EXCHANGE = "exchange"
    MINING_POOL = "mining_pool"
    TREASURY = "treasury"


class Signal(BaseModel):
    """
    Represents a computed blockchain signal with metadata and confidence score.
    
    Signals are generated by signal processors analyzing blockchain data and are
    persisted to BigQuery for insight generation.
    """
    model_config = ConfigDict(use_enum_values=True)
    
    signal_id: str = Field(
        ...,
        description="Unique identifier (UUID) for the signal"
    )
    signal_type: SignalType = Field(
        ...,
        description="Type of signal: mempool, exchange, miner, whale, treasury, or predictive"
    )
    block_height: int = Field(
        ...,
        ge=0,
        description="Bitcoin block height where signal was detected"
    )
    confidence: float = Field(
        ...,
        ge=0.0,
        le=1.0,
        description="Confidence score from 0.0 to 1.0 indicating signal reliability"
    )
    metadata: Dict[str, Any] = Field(
        ...,
        description="Signal-specific metadata (structure varies by signal_type)"
    )
    created_at: datetime = Field(
        ...,
        description="Timestamp when signal was generated"
    )
    processed: bool = Field(
        default=False,
        description="Whether insight has been generated from this signal"
    )
    processed_at: Optional[datetime] = Field(
        default=None,
        description="Timestamp when insight was generated from this signal"
    )
    
    @field_validator('signal_type', mode='before')
    @classmethod
    def validate_signal_type(cls, v):
        """Validate signal_type is a valid enum value."""
        if isinstance(v, str):
            try:
                return SignalType(v)
            except ValueError:
                raise ValueError(f"Invalid signal_type: {v}. Must be one of {[e.value for e in SignalType]}")
        return v


class Evidence(BaseModel):
    """
    Blockchain evidence supporting an insight.
    
    Contains references to specific blocks and transactions that provide
    verifiable proof for the insight.
    """
    block_heights: List[int] = Field(
        default_factory=list,
        description="Array of block heights referenced in this insight"
    )
    transaction_ids: List[str] = Field(
        default_factory=list,
        description="Array of transaction IDs (hashes) referenced in this insight"
    )
    
    @field_validator('block_heights')
    @classmethod
    def validate_block_heights(cls, v):
        """Ensure all block heights are non-negative."""
        if any(height < 0 for height in v):
            raise ValueError("Block heights must be non-negative")
        return v


class Insight(BaseModel):
    """
    AI-generated insight from a blockchain signal.
    
    Insights provide human-readable explanations of blockchain signals,
    including headlines, summaries, and blockchain evidence.
    """
    insight_id: str = Field(
        ...,
        description="Unique identifier (UUID) for the insight"
    )
    signal_id: str = Field(
        ...,
        description="Reference to the source signal that generated this insight"
    )
    category: SignalType = Field(
        ...,
        description="Insight category matching signal type"
    )
    headline: str = Field(
        ...,
        max_length=80,
        description="Short headline (max 80 characters) summarizing the insight"
    )
    summary: str = Field(
        ...,
        description="2-3 sentence explanation of why this insight matters"
    )
    confidence: float = Field(
        ...,
        ge=0.0,
        le=1.0,
        description="Confidence score inherited from source signal (0.0 to 1.0)"
    )
    evidence: Evidence = Field(
        ...,
        description="Blockchain evidence including block heights and transaction IDs"
    )
    chart_url: Optional[str] = Field(
        default=None,
        description="URL to chart visualization (null until populated by chart-renderer)"
    )
    created_at: datetime = Field(
        ...,
        description="Timestamp when insight was generated"
    )
    
    @field_validator('headline')
    @classmethod
    def validate_headline_length(cls, v):
        """Ensure headline is not empty and within length limit."""
        if not v or len(v.strip()) == 0:
            raise ValueError("Headline cannot be empty")
        if len(v) > 80:
            raise ValueError("Headline must be 80 characters or less")
        return v.strip()


class EntityInfo(BaseModel):
    """
    Information about a known blockchain entity.
    
    Entities include exchanges, mining pools, and treasury companies with
    associated addresses and metadata.
    """
    entity_id: str = Field(
        ...,
        description="Unique identifier for the entity"
    )
    entity_name: str = Field(
        ...,
        description="Human-readable name (e.g., Coinbase, Foundry USA, MicroStrategy)"
    )
    entity_type: EntityType = Field(
        ...,
        description="Type of entity: exchange, mining_pool, or treasury"
    )
    addresses: List[str] = Field(
        ...,
        min_length=1,
        description="Array of Bitcoin addresses associated with this entity"
    )
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional entity metadata (for treasury: ticker symbol and known BTC holdings)"
    )
    updated_at: datetime = Field(
        ...,
        description="Timestamp when entity record was last updated"
    )
    
    @field_validator('entity_type', mode='before')
    @classmethod
    def validate_entity_type(cls, v):
        """Validate entity_type is a valid enum value."""
        if isinstance(v, str):
            try:
                return EntityType(v)
            except ValueError:
                raise ValueError(f"Invalid entity_type: {v}. Must be one of {[e.value for e in EntityType]}")
        return v
    
    @field_validator('addresses')
    @classmethod
    def validate_addresses(cls, v):
        """Ensure addresses list is not empty."""
        if not v or len(v) == 0:
            raise ValueError("Entity must have at least one address")
        return v


# Type aliases for common use cases
SignalMetadata = Dict[str, Any]
InsightContent = Dict[str, str]  # For AI provider responses


class MempoolSignalMetadata(BaseModel):
    """Metadata structure for mempool signals."""
    fee_rate_median: float = Field(..., description="Median fee rate in sat/vB")
    fee_rate_change_pct: float = Field(..., description="Percentage change in fee rate")
    tx_count: int = Field(..., ge=0, description="Number of transactions in mempool")
    mempool_size_mb: float = Field(..., ge=0, description="Mempool size in megabytes")
    comparison_window: str = Field(..., description="Time window for comparison (e.g., '1h', '24h')")


class ExchangeSignalMetadata(BaseModel):
    """Metadata structure for exchange signals."""
    entity_id: str = Field(..., description="Entity identifier")
    entity_name: str = Field(..., description="Exchange name")
    flow_type: str = Field(..., description="Flow type: inflow or outflow")
    amount_btc: float = Field(..., ge=0, description="Amount in BTC")
    tx_count: int = Field(..., ge=0, description="Number of transactions")
    addresses: List[str] = Field(..., description="Involved addresses")


class TreasurySignalMetadata(BaseModel):
    """Metadata structure for treasury signals."""
    entity_id: str = Field(..., description="Entity identifier")
    entity_name: str = Field(..., description="Company name")
    company_ticker: str = Field(..., description="Stock ticker symbol")
    flow_type: str = Field(..., description="Flow type: accumulation or distribution")
    amount_btc: float = Field(..., ge=0, description="Amount in BTC")
    tx_count: int = Field(..., ge=0, description="Number of transactions")
    addresses: List[str] = Field(..., description="Involved addresses")
    known_holdings_btc: float = Field(..., ge=0, description="Known BTC holdings")
    holdings_change_pct: float = Field(..., description="Percentage change in holdings")


class MinerSignalMetadata(BaseModel):
    """Metadata structure for miner signals."""
    pool_name: str = Field(..., description="Mining pool name")
    amount_btc: float = Field(..., ge=0, description="Amount in BTC")
    treasury_balance_change: float = Field(..., description="Change in treasury balance")


class WhaleSignalMetadata(BaseModel):
    """Metadata structure for whale signals."""
    whale_address: str = Field(..., description="Whale address")
    amount_btc: float = Field(..., ge=0, description="Transaction amount in BTC")
    balance_btc: float = Field(..., ge=0, description="Current balance in BTC")


class PredictiveSignalMetadata(BaseModel):
    """Metadata structure for predictive signals."""
    prediction_type: str = Field(..., description="Type of prediction: fee_forecast or liquidity_pressure")
    predicted_value: float = Field(..., description="Predicted value")
    confidence_interval: List[float] = Field(..., min_length=2, max_length=2, description="Confidence interval [lower, upper]")
    forecast_horizon: str = Field(..., description="Forecast time horizon (e.g., '1h', '24h')")
    model_version: str = Field(..., description="Model version used for prediction")
    current_value: Optional[float] = Field(None, description="Current value for comparison")
